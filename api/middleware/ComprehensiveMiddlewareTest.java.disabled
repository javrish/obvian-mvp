package api.middleware;

import api.BaseUnitTest;
import api.middleware.*;
import api.security.*;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;

import javax.servlet.FilterChain;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

/**
 * Comprehensive unit tests for all middleware components
 */
@DisplayName("Comprehensive Middleware Tests")
public class ComprehensiveMiddlewareTest extends BaseUnitTest {

    @Nested
    @DisplayName("JWT Authentication Filter Tests")
    class JwtAuthenticationFilterTests {

        @Mock
        private JwtUtil jwtUtil;

        @InjectMocks
        private JwtAuthenticationFilter jwtAuthenticationFilter;

        @Mock
        private FilterChain filterChain;

        @Test
        @DisplayName("Should authenticate valid JWT token")
        void shouldAuthenticateValidJwtToken() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();
            
            request.addHeader("Authorization", "Bearer valid.jwt.token");
            when(jwtUtil.validateToken("valid.jwt.token")).thenReturn(true);
            when(jwtUtil.getUsernameFromToken("valid.jwt.token")).thenReturn("testuser");

            jwtAuthenticationFilter.doFilterInternal(request, response, filterChain);

            verify(filterChain).doFilter(request, response);
        }

        @Test
        @DisplayName("Should reject invalid JWT token")
        void shouldRejectInvalidJwtToken() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();
            
            request.addHeader("Authorization", "Bearer invalid.jwt.token");
            when(jwtUtil.validateToken("invalid.jwt.token")).thenReturn(false);

            jwtAuthenticationFilter.doFilterInternal(request, response, filterChain);

            assertThat(response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
        }

        @Test
        @DisplayName("Should handle missing authorization header")
        void shouldHandleMissingAuthorizationHeader() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();

            jwtAuthenticationFilter.doFilterInternal(request, response, filterChain);

            verify(filterChain).doFilter(request, response);
        }

        @Test
        @DisplayName("Should handle malformed authorization header")
        void shouldHandleMalformedAuthorizationHeader() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();
            
            request.addHeader("Authorization", "InvalidFormat");

            jwtAuthenticationFilter.doFilterInternal(request, response, filterChain);

            verify(filterChain).doFilter(request, response);
        }
    }

    @Nested
    @DisplayName("Rate Limiting Filter Tests")
    class RateLimitingFilterTests {

        @InjectMocks
        private RateLimitingFilter rateLimitingFilter;

        @Mock
        private FilterChain filterChain;

        @Test
        @DisplayName("Should allow requests within rate limit")
        void shouldAllowRequestsWithinRateLimit() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();
            
            request.setRemoteAddr("192.168.1.1");

            rateLimitingFilter.doFilter(request, response, filterChain);

            verify(filterChain).doFilter(request, response);
            assertThat(response.getStatus()).isNotEqualTo(HttpServletResponse.SC_TOO_MANY_REQUESTS);
        }

        @Test
        @DisplayName("Should block requests exceeding rate limit")
        void shouldBlockRequestsExceedingRateLimit() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();
            
            request.setRemoteAddr("192.168.1.1");

            // Simulate multiple requests to exceed rate limit
            for (int i = 0; i < 100; i++) {
                rateLimitingFilter.doFilter(request, response, filterChain);
            }

            // This request should be rate limited
            rateLimitingFilter.doFilter(request, response, filterChain);

            // Verify that at some point rate limiting kicks in
            // Note: Actual implementation would depend on rate limiting logic
        }

        @Test
        @DisplayName("Should handle different IP addresses separately")
        void shouldHandleDifferentIpAddressesSeparately() throws Exception {
            MockHttpServletRequest request1 = new MockHttpServletRequest();
            MockHttpServletRequest request2 = new MockHttpServletRequest();
            MockHttpServletResponse response1 = new MockHttpServletResponse();
            MockHttpServletResponse response2 = new MockHttpServletResponse();
            
            request1.setRemoteAddr("192.168.1.1");
            request2.setRemoteAddr("192.168.1.2");

            rateLimitingFilter.doFilter(request1, response1, filterChain);
            rateLimitingFilter.doFilter(request2, response2, filterChain);

            verify(filterChain, times(2)).doFilter(any(), any());
        }
    }

    @Nested
    @DisplayName("Request Validation Filter Tests")
    class RequestValidationFilterTests {

        @InjectMocks
        private RequestValidationFilter requestValidationFilter;

        @Mock
        private FilterChain filterChain;

        @Test
        @DisplayName("Should validate request content type")
        void shouldValidateRequestContentType() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();
            
            request.setContentType("application/json");
            request.setMethod("POST");

            requestValidationFilter.doFilter(request, response, filterChain);

            verify(filterChain).doFilter(request, response);
        }

        @Test
        @DisplayName("Should reject invalid content type")
        void shouldRejectInvalidContentType() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();
            
            request.setContentType("text/plain");
            request.setMethod("POST");

            requestValidationFilter.doFilter(request, response, filterChain);

            // Should reject non-JSON content type for POST requests
            assertThat(response.getStatus()).isEqualTo(HttpServletResponse.SC_BAD_REQUEST);
        }

        @Test
        @DisplayName("Should validate request size limits")
        void shouldValidateRequestSizeLimits() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();
            
            request.setContentType("application/json");
            request.setMethod("POST");
            
            // Simulate large request body
            String largeContent = "x".repeat(10 * 1024 * 1024); // 10MB
            request.setContent(largeContent.getBytes());

            requestValidationFilter.doFilter(request, response, filterChain);

            // Should reject oversized requests
            assertThat(response.getStatus()).isEqualTo(HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE);
        }

        @Test
        @DisplayName("Should sanitize request parameters")
        void shouldSanitizeRequestParameters() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();
            
            request.addParameter("query", "<script>alert('xss')</script>");

            requestValidationFilter.doFilter(request, response, filterChain);

            // Parameters should be sanitized
            verify(filterChain).doFilter(any(HttpServletRequest.class), eq(response));
        }
    }

    @Nested
    @DisplayName("Monitoring Interceptor Tests")
    class MonitoringInterceptorTests {

        @InjectMocks
        private MonitoringInterceptor monitoringInterceptor;

        @Test
        @DisplayName("Should record request metrics")
        void shouldRecordRequestMetrics() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();
            
            request.setRequestURI("/api/v1/prompts/execute");
            request.setMethod("POST");

            boolean result = monitoringInterceptor.preHandle(request, response, new Object());
            monitoringInterceptor.afterCompletion(request, response, new Object(), null);

            assertThat(result).isTrue();
            // Verify metrics are recorded (would depend on actual implementation)
        }

        @Test
        @DisplayName("Should handle request timing")
        void shouldHandleRequestTiming() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();

            monitoringInterceptor.preHandle(request, response, new Object());
            
            // Simulate some processing time
            Thread.sleep(10);
            
            monitoringInterceptor.afterCompletion(request, response, new Object(), null);

            // Verify timing is recorded
        }

        @Test
        @DisplayName("Should track error rates")
        void shouldTrackErrorRates() throws Exception {
            MockHttpServletRequest request = new MockHttpServletRequest();
            MockHttpServletResponse response = new MockHttpServletResponse();
            
            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);

            monitoringInterceptor.preHandle(request, response, new Object());
            monitoringInterceptor.afterCompletion(request, response, new Object(), 
                new RuntimeException("Test error"));

            // Verify error metrics are recorded
        }
    }
}