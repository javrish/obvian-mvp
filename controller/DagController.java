package api.controller;

import api.model.DagExecutionRequest;
import api.model.DagExecutionResponse;
import api.model.ExecutionStatusResponse;
import api.service.DagExecutionService;
import api.service.security.AuthorizationService;
import api.service.security.DagExecutionAuditor;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import core.DagValidationResult;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

/**
 * REST controller for DAG execution endpoints
 */
@RestController
@RequestMapping("/api/v1/dags")
@Tag(name = "DAG Execution", description = "DAG execution endpoints")
public class DagController {
    
    private final DagExecutionService dagExecutionService;
    private final AuthorizationService authorizationService;
    private final DagExecutionAuditor auditor;
    private final ObjectMapper objectMapper;
    
    @Autowired
    public DagController(DagExecutionService dagExecutionService, 
                        AuthorizationService authorizationService,
                        DagExecutionAuditor auditor) {
        this.dagExecutionService = dagExecutionService;
        this.authorizationService = authorizationService;
        this.auditor = auditor;
        this.objectMapper = new ObjectMapper();
    }
    
    /**
     * Execute a structured DAG
     * POST /api/v1/dags/execute
     */
    @PostMapping("/execute")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN') or hasAuthority('dag:execute')")
    @Operation(summary = "Execute a DAG", description = "Execute a Directed Acyclic Graph (DAG) of tasks")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "DAG executed successfully"),
        @ApiResponse(responseCode = "202", description = "DAG execution started (async mode)"),
        @ApiResponse(responseCode = "400", description = "Invalid DAG structure or request data"),
        @ApiResponse(responseCode = "401", description = "Authentication required"),
        @ApiResponse(responseCode = "403", description = "Insufficient permissions"),
        @ApiResponse(responseCode = "404", description = "Resource not found"),
        @ApiResponse(responseCode = "413", description = "Request entity too large"),
        @ApiResponse(responseCode = "500", description = "Internal server error")
    })
    public ResponseEntity<DagExecutionResponse> executeDag(@Valid @RequestBody DagExecutionRequest request) {
        
        try {
            // Verify DAG execution permission and get authenticated user context
            authorizationService.requireDagExecutionPermission();
            Map<String, Object> userContext = authorizationService.createSecureUserContext();
            String currentUserId = authorizationService.getCurrentUserId();
            
            // Log execution start for audit
            auditor.logExecutionStart(
                "pending", // Execution ID will be generated by service
                authorizationService.getCurrentUsername(),
                request.getDag(),
                request.isAsync(),
                request.isDryRun()
            );
            
            // Execute the DAG with validated user context
            DagExecutionResponse response = dagExecutionService.executeDag(request, userContext);
            
            // Return appropriate HTTP status
            HttpStatus status = determineHttpStatus(response);
            
            return ResponseEntity.status(status).body(response);
            
        } catch (AccessDeniedException e) {
            auditor.logSecurityEvent("DAG_EXECUTION_DENIED", 
                authorizationService.getCurrentUsername(), 
                "dag_execution", "EXECUTE", false, e.getMessage());
            DagExecutionResponse errorResponse = DagExecutionResponse.failure(
                "unknown", "Access denied: " + e.getMessage(), "ACCESS_DENIED");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(errorResponse);
        } catch (IllegalArgumentException e) {
            auditor.logInputValidationFailure(
                authorizationService.getCurrentUsername(), 
                e.getMessage(), "DAG_EXECUTION_REQUEST");
            DagExecutionResponse errorResponse = DagExecutionResponse.failure(
                "unknown", "Validation error: " + e.getMessage(), "VALIDATION_ERROR");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
        } catch (Exception e) {
            auditor.logSecurityEvent("DAG_EXECUTION_ERROR", 
                authorizationService.getCurrentUsername(), 
                "dag_execution", "EXECUTE", false, "Internal error: " + e.getMessage());
            DagExecutionResponse errorResponse = DagExecutionResponse.failure(
                "unknown", "Internal server error: " + e.getMessage(), "INTERNAL_ERROR");
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
    
    /**
     * Validate a DAG structure without executing it
     * POST /api/v1/dags/validate
     */
    @PostMapping("/validate")
    public ResponseEntity<Map<String, Object>> validateDag(@Valid @RequestBody DagExecutionRequest request) {
        try {
            // Validate DAG structure
            DagValidationResult validationResult = dagExecutionService.validatePluginDependencies(request.getDag());
            
            Map<String, Object> response = new HashMap<>();
            response.put("valid", validationResult.isValid());
            response.put("errors", validationResult.getErrors());
            response.put("warnings", validationResult.getWarnings());
            
            // Add suggestions based on validation results
            if (!validationResult.isValid()) {
                response.put("suggestions", validationResult.getErrors().stream()
                    .map(error -> error.getSuggestion())
                    .filter(suggestion -> suggestion != null && !suggestion.isEmpty())
                    .distinct()
                    .toList());
            }
            
            HttpStatus status = validationResult.isValid() ? HttpStatus.OK : HttpStatus.BAD_REQUEST;
            return ResponseEntity.status(status).body(response);
            
        } catch (Exception e) {
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("valid", false);
            errorResponse.put("error", "Validation failed: " + e.getMessage());
            errorResponse.put("errorType", "VALIDATION_ERROR");
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
    
    /**
     * Get execution status for async DAG executions
     * GET /api/v1/dags/status/{executionId}
     */
    @GetMapping("/status/{executionId}")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public ResponseEntity<ExecutionStatusResponse> getExecutionStatus(@PathVariable String executionId) {
        try {
            // Validate execution ID and verify ownership
            String validatedExecutionId = authorizationService.validateExecutionId(executionId);
            String currentUserId = authorizationService.getCurrentUserId();
            
            // Get the execution to verify ownership (this should be implemented in the service)
            ExecutionStatusResponse response = dagExecutionService.getExecutionStatus(validatedExecutionId);
            
            // Verify user can access this execution (implement ownership check in service)
            // For now, let's assume the service layer will handle this
            
            // Log status access
            auditor.logStatusAccess(validatedExecutionId, authorizationService.getCurrentUsername(), true, null);
            
            HttpStatus status = HttpStatus.OK;
            // Check for NOT_FOUND first (higher priority than generic FAILED status)
            if (response.getResult() != null && !response.getResult().isSuccess() && 
                      "NOT_FOUND".equals(response.getResult().getErrorType())) {
                status = HttpStatus.NOT_FOUND;
            } else if (response.getStatus() == ExecutionStatusResponse.ExecutionStatus.FAILED) {
                status = HttpStatus.INTERNAL_SERVER_ERROR;
            }
            
            return ResponseEntity.status(status).body(response);
            
        } catch (AccessDeniedException e) {
            auditor.logStatusAccess(executionId, authorizationService.getCurrentUsername(), false, e.getMessage());
            ExecutionStatusResponse errorResponse = ExecutionStatusResponse.failed(
                executionId, 
                createErrorPromptResponse(executionId, "Access denied: " + e.getMessage())
            );
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(errorResponse);
        } catch (IllegalArgumentException e) {
            auditor.logInputValidationFailure(authorizationService.getCurrentUsername(), 
                e.getMessage(), "EXECUTION_ID");
            ExecutionStatusResponse errorResponse = ExecutionStatusResponse.failed(
                executionId, 
                createErrorPromptResponse(executionId, "Invalid execution ID: " + e.getMessage())
            );
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
        } catch (Exception e) {
            auditor.logStatusAccess(executionId, authorizationService.getCurrentUsername(), false, 
                "Internal error: " + e.getMessage());
            ExecutionStatusResponse errorResponse = ExecutionStatusResponse.failed(
                executionId, 
                createErrorPromptResponse(executionId, "Failed to get status: " + e.getMessage())
            );
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
    
    /**
     * Cancel an async DAG execution
     * DELETE /api/v1/dags/status/{executionId}
     */
    @DeleteMapping("/status/{executionId}")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public ResponseEntity<Map<String, Object>> cancelExecution(@PathVariable String executionId) {
        try {
            // Validate execution ID
            String validatedExecutionId = authorizationService.validateExecutionId(executionId);
            String currentUsername = authorizationService.getCurrentUsername();
            
            // Attempt cancellation
            boolean cancelled = dagExecutionService.cancelExecution(validatedExecutionId);
            
            // Log cancellation attempt
            auditor.logExecutionCancellation(validatedExecutionId, currentUsername, true, cancelled, null);
            
            Map<String, Object> response = new HashMap<>();
            response.put("executionId", validatedExecutionId);
            response.put("cancelled", cancelled);
            response.put("message", cancelled ? "Execution cancelled successfully" : "Execution not found or already completed");
            
            HttpStatus status = cancelled ? HttpStatus.OK : HttpStatus.NOT_FOUND;
            return ResponseEntity.status(status).body(response);
            
        } catch (AccessDeniedException e) {
            auditor.logExecutionCancellation(executionId, authorizationService.getCurrentUsername(), 
                false, false, e.getMessage());
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("executionId", executionId);
            errorResponse.put("cancelled", false);
            errorResponse.put("error", "Access denied: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(errorResponse);
        } catch (IllegalArgumentException e) {
            auditor.logInputValidationFailure(authorizationService.getCurrentUsername(), 
                e.getMessage(), "EXECUTION_ID");
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("executionId", executionId);
            errorResponse.put("cancelled", false);
            errorResponse.put("error", "Invalid execution ID: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
        } catch (Exception e) {
            auditor.logExecutionCancellation(executionId, authorizationService.getCurrentUsername(), 
                true, false, "Internal error: " + e.getMessage());
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("executionId", executionId);
            errorResponse.put("cancelled", false);
            errorResponse.put("error", "Failed to cancel execution: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
    
    /**
     * Health check endpoint for DAG execution service
     * GET /api/v1/dags/health
     */
    @GetMapping("/health")
    public ResponseEntity<Map<String, Object>> health() {
        Map<String, Object> health = new HashMap<>();
        health.put("status", "healthy");
        health.put("service", "DagExecutionService");
        health.put("timestamp", System.currentTimeMillis());
        
        // Add basic service checks
        Map<String, String> components = new HashMap<>();
        components.put("dagValidator", "healthy");
        components.put("dagExecutor", "healthy");
        components.put("pluginRouter", "healthy");
        components.put("memoryStore", "healthy");
        health.put("components", components);
        
        return ResponseEntity.ok(health);
    }
    
    /**
     * Get DAG execution capabilities and supported features
     * GET /api/v1/dags/capabilities
     */
    @GetMapping("/capabilities")
    public ResponseEntity<Map<String, Object>> getCapabilities() {
        Map<String, Object> response = new HashMap<>();
        
        Map<String, Object> features = new HashMap<>();
        features.put("dryRun", Map.of(
            "supported", true,
            "description", "Validate DAG structure and execution plan without running plugins"
        ));
        
        features.put("asyncExecution", Map.of(
            "supported", true,
            "description", "Execute DAGs asynchronously with status polling"
        ));
        
        features.put("traceMode", Map.of(
            "supported", true,
            "description", "Detailed execution traces with timing and plugin information"
        ));
        
        features.put("pluginValidation", Map.of(
            "supported", true,
            "description", "Pre-execution validation of plugin availability and health"
        ));
        
        features.put("contextMerging", Map.of(
            "supported", true,
            "description", "Merge execution context from headers and request body"
        ));
        
        features.put("tokenSubstitution", Map.of(
            "supported", true,
            "description", "Token substitution in input parameters using ${token} syntax"
        ));
        
        response.put("features", features);
        
        Map<String, Object> limits = new HashMap<>();
        limits.put("maxNodes", 100);
        limits.put("maxExecutionTimeMs", 300000); // 5 minutes
        limits.put("maxContextSize", 1048576); // 1MB
        response.put("limits", limits);
        
        Map<String, Object> validation = new HashMap<>();
        validation.put("structuralValidation", "Validates DAG structure, dependencies, and circular references");
        validation.put("pluginValidation", "Checks plugin availability and health before execution");
        validation.put("parameterValidation", "Validates input parameters and token substitution");
        validation.put("contextValidation", "Validates and sanitizes execution context");
        response.put("validation", validation);
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Get detailed error information for debugging
     * GET /api/v1/dags/errors/{executionId}
     */
    @GetMapping("/errors/{executionId}")
    public ResponseEntity<Map<String, Object>> getExecutionErrors(@PathVariable String executionId) {
        try {
            ExecutionStatusResponse statusResponse = dagExecutionService.getExecutionStatus(executionId);
            
            Map<String, Object> response = new HashMap<>();
            response.put("executionId", executionId);
            
            if (statusResponse.getResult() != null && !statusResponse.getResult().isSuccess()) {
                response.put("hasErrors", true);
                response.put("errorType", statusResponse.getResult().getErrorType());
                response.put("errorMessage", statusResponse.getResult().getMessage());
                
                // Add node-specific errors if available
                if (statusResponse.getResult().getNodeResults() != null) {
                    Map<String, Object> nodeErrors = new HashMap<>();
                    statusResponse.getResult().getNodeResults().forEach((nodeId, nodeResult) -> {
                        if (!nodeResult.isSuccess()) {
                            Map<String, Object> nodeError = new HashMap<>();
                            nodeError.put("status", nodeResult.getStatus());
                            nodeError.put("message", nodeResult.getResult() != null ? nodeResult.getResult().getMessage() : "Unknown error");
                            nodeError.put("errorType", nodeResult.getResult() != null && nodeResult.getResult().getErrorType() != null ? 
                                nodeResult.getResult().getErrorType().toString() : "UNKNOWN");
                            nodeErrors.put(nodeId, nodeError);
                        }
                    });
                    response.put("nodeErrors", nodeErrors);
                }
            } else {
                response.put("hasErrors", false);
                response.put("message", "No errors found for this execution");
            }
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("executionId", executionId);
            errorResponse.put("error", "Failed to retrieve error information: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
    
    private HttpStatus determineHttpStatus(DagExecutionResponse response) {
        if (response.isSuccess()) {
            return response.isAsync() ? HttpStatus.ACCEPTED : HttpStatus.OK;
        }
        
        String errorType = response.getErrorType();
        if ("VALIDATION_ERROR".equals(errorType) || "DRY_RUN_ERROR".equals(errorType)) {
            return HttpStatus.BAD_REQUEST;
        } else if ("NOT_FOUND".equals(errorType)) {
            return HttpStatus.NOT_FOUND;
        } else if ("EXECUTION_ERROR".equals(errorType)) {
            return HttpStatus.INTERNAL_SERVER_ERROR;
        } else {
            return HttpStatus.INTERNAL_SERVER_ERROR;
        }
    }
    
    // Removed unsafe parseUserContext method - now using AuthorizationService for secure user context
    
    private api.model.PromptExecutionResponse createErrorPromptResponse(String executionId, String message) {
        return api.model.PromptExecutionResponse.failure(executionId, message, "INTERNAL_ERROR");
    }
}